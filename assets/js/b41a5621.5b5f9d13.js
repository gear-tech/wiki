"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[6426],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=o.createContext({}),s=function(e){var t=o.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return o.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,f=d["".concat(u,".").concat(m)]||d[m]||p[m]||r;return n?o.createElement(f,i(i({ref:t},c),{},{components:n})):o.createElement(f,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9014:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return p}});var o=n(7462),a=n(3366),r=(n(7294),n(3905)),i=["components"],l={sidebar_label:"gNFT (ERC-721)",sidebar_position:4},u="Gear Non-Fungible Token",s={unversionedId:"examples/gnft-721",id:"examples/gnft-721",title:"Gear Non-Fungible Token",description:"Introduction",source:"@site/docs/examples/gnft-721.md",sourceDirName:"examples",slug:"/examples/gnft-721",permalink:"/examples/gnft-721",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/gnft-721.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_label:"gNFT (ERC-721)",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"gFT (ERC-20)",permalink:"/examples/gft-20"},next:{title:"gMT (ERC-1155)",permalink:"/examples/gmt-1155"}},c={},p=[{value:"Introduction",id:"introduction",level:3},{value:"Default non-fungible-token implementation",id:"default-non-fungible-token-implementation",level:3},{value:"Developing your non-fungible-token contract",id:"developing-your-non-fungible-token-contract",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gear-non-fungible-token"},"Gear Non-Fungible Token"),(0,r.kt)("h3",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Non-fungible tokens (NFTs) are unique cryptographic tokens on a blockchain that are used to prove an ownership of a digital asset, such as digital art or gaming assets. The difference from fungible tokens is that the fungible tokens store a value, while non-fungible tokens store a cryptographic certificate."),(0,r.kt)("p",null,"Under the hood, a non-fungible token consists of a unique token identifier, or token ID, which is mapped to an owner identifier and stored inside a NFT smart contract.",(0,r.kt)("center",null," ",(0,r.kt)("em",null,(0,r.kt)("strong",null,"token_id"))," \u2192 ",(0,r.kt)("em",null,(0,r.kt)("strong",null,"address"))," ")),(0,r.kt)("p",null,"When the owner of a given token ID wishes to transfer it to another user, it is easy to verify ownership and reassign the token to a new owner."),(0,r.kt)("p",null,"This article explains the programming interface, data structure, basic functions and explains their purpose. It can be used as is or modified to suit your own scenarios. Anyone can easily create their own application and run it on the Gear Network. The source code is available on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/non-fungible-token"},"GitHub"),". "),(0,r.kt)("h3",{id:"default-non-fungible-token-implementation"},"Default non-fungible-token implementation"),(0,r.kt)("p",null,"The functions that must be supported by each non-fungible-token contract:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"transfer(to, token_id)")," - is a function that allows you to transfer a token with the ",(0,r.kt)("em",{parentName:"li"},"token_id")," number to the ",(0,r.kt)("em",{parentName:"li"},"to")," account;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"approve(approved_account, token_id)")," - is a function that allows you to give the right to dispose of the token to the specified ",(0,r.kt)("em",{parentName:"li"},"approved_account"),". This functionality can be useful on marketplaces or auctions as when the owner wants to sell his token, they can put it on a marketplace/auction, so the contract will be able to send this token to the new owner at some point;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"mint(to, token_id, metadata)")," is a function that creates a new token. Metadata can include any information about the token: it can be a link to a specific resource, a description of the token, etc;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"burn(from, token_id)")," is a function that removes the token with the mentioned ",(0,r.kt)("em",{parentName:"li"},"token_id")," from the contract.")),(0,r.kt)("p",null,"The default implementation of the NFT contract is provided in the gear library: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/gear-lib/tree/master/src/non_fungible_token"},"gear-lib/non_fungible_token"),"."),(0,r.kt)("p",null,"To use the default implementation you should include the packages into your ",(0,r.kt)("em",{parentName:"p"},"Cargo.toml")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'gear-lib = { git = "https://github.com/gear-dapps/gear-lib.git" }\ngear-lib-derive = { git = "https://github.com/gear-dapps/gear-lib.git" }\n')),(0,r.kt)("p",null,"The states that non-fungible-contract store are defined in the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"NFTState"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Default)]\npub struct NFTState {\n    pub name: String,\n    pub symbol: String,\n    pub base_uri: String,\n    pub owner_by_id: BTreeMap<TokenId, ActorId>,\n    pub token_approvals: BTreeMap<TokenId, Vec<ActorId>>,\n    pub token_metadata_by_id: BTreeMap<TokenId, Option<TokenMetadata>>,\n    pub tokens_for_owner: BTreeMap<ActorId, Vec<TokenId>>,\n    pub royalties: Option<Royalties>,\n}\n")),(0,r.kt)("p",null,"To reuse the default struct you need derive the NFTStateKeeper trait and mark the corresponding field with the #","[NFTStateField]"," attribute.  You can also add your fields in your NFT contract. For example, let's add the owner's address to the contract and the ",(0,r.kt)("inlineCode",{parentName:"p"},"token_id")," that will track the current number of token:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use derive_traits::{NFTStateKeeper, NFTCore, NFTMetaState};\nuse gear_contract_libraries::non_fungible_token::{nft_core::*, state::*, token::*};\n\n#[derive(Debug, Default, NFTStateKeeper, NFTCore, NFTMetaState)]\npub struct NFT {\n    #[NFTStateField]\n    pub token: NFTState,\n    pub token_id: TokenId,\n    pub owner: ActorId,\n}\n")),(0,r.kt)("p",null,"To inherit the default logic functions you need to derive NFTCore trait. Accordingly, for reading contracts states you need NFTMetaState trait."),(0,r.kt)("p",null,"Let's write the whole implementation of the NFT contract. First, we define the message\nwhich will initialize the contract and messages that our contract will process:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Encode, Decode, TypeInfo)]\npub struct InitNFT {\n    pub name: String,\n    pub symbol: String,\n    pub base_uri: String,\n}\n\npub enum NFTAction {\n    Mint {\n        to: ActorId,\n        token_id: TokenId,\n    },\n    Burn {\n        token_id: TokenId,\n    },\n    Transfer {\n        to: ActorId,\n        token_id: TokenId,\n    },\n    Approve {\n        to: ActorId,\n        token_id: TokenId,\n    },\n}\n")),(0,r.kt)("p",null,"Then the default NFT contract implementation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, Default, NFTStateKeeper, NFTCore, NFTMetaState)]\npub struct NFT {\n    #[NFTStateField]\n    pub token: NFTState,\n    pub token_id: TokenId,\n    pub owner: ActorId,\n}\n\nstatic mut CONTRACT: Option<NFT> = None;\n\n#[no_mangle]\npub unsafe extern "C" fn init() {\n    let config: InitNFT = msg::load().expect("Unable to decode InitNFT");\n    let mut nft = NFT::default();\n    nft.token.name = config.name;\n    nft.token.symbol = config.symbol;\n    nft.token.base_uri = config.base_uri;\n    nft.owner = msg::source();\n    CONTRACT = Some(nft);\n}\n\n#[no_mangle]\npub unsafe extern "C" fn handle() {\n    let action: NFTAction = msg::load().expect("Could not load msg");\n    let nft = CONTRACT.get_or_insert(NFT::default());\n    match action {\n        NFTAction::Mint { to, token_id } => NFTCore::mint(&to, token_id, None),\n        NFTAction::Burn { token_id } => NFTCore::burn(nft, token_id),\n        NFTAction::Transfer { to, token_id } => NFTCore::transfer(nft, &to, token_id),\n        NFTAction::Approve { to, token_id } => NFTCore::approve(nft, &to, token_id),\n    }\n}\n')),(0,r.kt)("h3",{id:"developing-your-non-fungible-token-contract"},"Developing your non-fungible-token contract"),(0,r.kt)("p",null,"Next, let's rewrite the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," function. Our ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," function will create token for the account that send ",(0,r.kt)("inlineCode",{parentName:"p"},"Mint")," message  and require the metadata as an input argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum NFTAction {\n    Mint {\n        token_metadata: TokenMetadata,\n        token_id: TokenId,\n    },\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TokenMetadata")," is also defined in the gear NFT library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug, Default, Encode, Decode, Clone, TypeInfo)]\npub struct TokenMetadata {\n    // ex. "CryptoKitty #100"\n    pub name: String,\n    // free-form description\n    pub description: String,\n    // URL to associated media, preferably to decentralized, content-addressed storage\n    pub media: String,\n    // URL to an off-chain JSON file with more info.\n    pub reference: String,\n}\n')),(0,r.kt)("p",null,"Define a trait for our new function that will extend the default ",(0,r.kt)("inlineCode",{parentName:"p"},"NFTCore")," trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait MyNFTCore: NFTCore {\n    fn mint(&mut self, token_metadata: TokenMetadata);\n}\n")),(0,r.kt)("p",null,"and write the implementation of that trait:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl MyNFTCore for NFT {\n    fn mint(&mut self, token_metadata: TokenMetadata) {\n        NFTCore::mint(self, &msg::source(), self.token_id, Some(token_metadata));\n        self.token_id = self.token_id.saturating_add(U256::one());\n    }\n}\n")),(0,r.kt)("p",null,"Accordingly, it is necessary to make changes to the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub unsafe extern "C" fn handle() {\n    let action: NFTAction = msg::load().expect("Could not load msg");\n    let nft = CONTRACT.get_or_insert(NFT::default());\n    match action {\n        NFTAction::Mint { token_metadata } => MyNFTCore::mint(token_metadata),\n        NFTAction::Burn { token_id } => NFTCore::burn(nft, token_id),\n        NFTAction::Transfer { to, token_id } => NFTCore::transfer(nft, &to, token_id),\n        NFTAction::Approve { to, token_id } => NFTCore::approve(nft, &to, token_id),\n    }\n}\n')),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Gear provides a reusable ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/non-fungible-token/tree/master/nft/src"},"library")," with core functionality for the gNFT protocol. By using object composition, that library can be utilized within a custom NFT contract implementation in order to minimize duplication of community available code."),(0,r.kt)("p",null,"A source code of the NFT marketplace provided by Gear is available on GitHub: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/non-fungible-token/tree/master/nft-marketplace/src"},"nft-marketplace/src"),"."),(0,r.kt)("p",null,"See also an example of the smart contract testing implementation based on ",(0,r.kt)("inlineCode",{parentName:"p"},"gtest"),": ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/non-fungible-token/tree/master/nft-marketplace/tests"},"nft-marketplace/tests"),"."),(0,r.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to this article: ",(0,r.kt)("a",{parentName:"p",href:"/developing-contracts/testing"},"Program Testing"),"."))}m.isMDXComponent=!0}}]);
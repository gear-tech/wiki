"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[1770],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return d}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(r),d=a,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return r?n.createElement(g,s(s({ref:t},p),{},{components:r})):n.createElement(g,s({ref:t},p))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=r[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},9580:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return m}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),s=["components"],i={sidebar_label:"Message Format",sidebar_position:3},l="Message communication format",c={unversionedId:"developing-contracts/messaging",id:"developing-contracts/messaging",title:"Message communication format",description:"Interaction with each program takes place by messaging.",source:"@site/docs/developing-contracts/messaging.md",sourceDirName:"developing-contracts",slug:"/developing-contracts/messaging",permalink:"/developing-contracts/messaging",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/developing-contracts/messaging.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"Message Format",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Program State",permalink:"/developing-contracts/gear-program"},next:{title:"Interaction Between Programs",permalink:"/developing-contracts/interactions-between-programs"}},p={},m=[{value:"Types of messages",id:"types-of-messages",level:2},{value:"Gas",id:"gas",level:2},{value:"Message process module",id:"message-process-module",level:2},{value:"Understandable messages. Encode/Decode traits",id:"understandable-messages-encodedecode-traits",level:2}],u={toc:m};function d(e){var t=e.components,r=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"message-communication-format"},"Message communication format"),(0,o.kt)("p",null,"Interaction with each program takes place by messaging."),(0,o.kt)("p",null,"Messages in Gear have common interface with the following parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Source account"),(0,o.kt)("li",{parentName:"ul"},"Target account"),(0,o.kt)("li",{parentName:"ul"},"Payload,"),(0,o.kt)("li",{parentName:"ul"},"Gas limit"),(0,o.kt)("li",{parentName:"ul"},"Value")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Gas limit")," is the amount of gas that users are willing to spend to process the message."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Value")," is a currency value to be transferred to the target account. In the special message of the initial program upload, the value will be transferred to a balance of the newly created account for the program."),(0,o.kt)("h2",{id:"types-of-messages"},"Types of messages"),(0,o.kt)("p",null,"In the case of the program, there are the following types of messages:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"From user to program"),(0,o.kt)("li",{parentName:"ul"},"From program to program"),(0,o.kt)("li",{parentName:"ul"},"From program to user"),(0,o.kt)("li",{parentName:"ul"},"A special message from the user to upload a new program to the network. The payload must contain the WASM file of the program itself. Target account must not be specified - it will be created as a part of processing message post.")),(0,o.kt)("h2",{id:"gas"},"Gas"),(0,o.kt)("p",null,"Gear node charges a gas fee during message processing. The gas fee is linear - 64000 gas per allocated memory page of size 64KB and 1000 gas per instrumented WASM instruction. Messages from transactions with the highest fee are taken first. In this case, messages from transactions with the lowest fee can be delayed or even never end up in the processing queue. If a transaction is processed before the limit is reached, the rest of the gas will be returned to the sending account."),(0,o.kt)("h2",{id:"message-process-module"},"Message process module"),(0,o.kt)("p",null,"Depending on the context the program interprets messages differently. To process messages in Gear programs, the ",(0,o.kt)("inlineCode",{parentName:"p"},"msg")," module from the proprietary ",(0,o.kt)("inlineCode",{parentName:"p"},"gstd")," standard library is used. All available functions described here:"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.gear.rs/gstd/msg/index.html"},"https://docs.gear.rs/gstd/msg/index.html")),(0,o.kt)("h2",{id:"understandable-messages-encodedecode-traits"},"Understandable messages. Encode/Decode traits"),(0,o.kt)("p",null,"Gear uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"parity-scale-codec"),", a Rust implementation of the SCALE Codec. SCALE is a lightweight format that allows encoding/decoding which makes it highly suitable for resource-constrained execution environments like blockchain runtimes and low-power/low-memory devices."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Encode, Decode)]\nenum MyType {\n    MyStruct { field: ... },\n    ...\n}\n")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://substrate.dev/docs/en/knowledgebase/advanced/codec"},"Learn more about SCALE Codec")))}d.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[9897],{3905:function(t,e,n){n.d(e,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var s=r.createContext({}),c=function(t){var e=r.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},p=function(t){var e=c(t.components);return r.createElement(s.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,o=t.originalType,s=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),d=c(n),m=a,y=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(y,l(l({ref:e},p),{},{components:n})):r.createElement(y,l({ref:e},p))}));function m(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=n.length,l=new Array(o);l[0]=d;var i={};for(var s in e)hasOwnProperty.call(e,s)&&(i[s]=e[s]);i.originalType=t,i.mdxType="string"==typeof t?t:a,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7463:function(t,e,n){n.r(e),n.d(e,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),l=["components"],i={sidebar_label:"Lottery",sidebar_position:9},s="Lottery",c={unversionedId:"examples/lottery",id:"examples/lottery",title:"Lottery",description:"Introduction",source:"@site/docs/examples/lottery.md",sourceDirName:"examples",slug:"/examples/lottery",permalink:"/examples/lottery",draft:!1,editUrl:"https://github.com/gear-tech/wiki/edit/master/docs/examples/lottery.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_label:"Lottery",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Escrow",permalink:"/examples/escrow"},next:{title:"Dutch Auction",permalink:"/examples/dutch-auction"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Source files",id:"source-files",level:2},{value:"Structs",id:"structs",level:2},{value:"Enums",id:"enums",level:2},{value:"Functions",id:"functions",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:u};function m(t){var e=t.components,n=(0,a.Z)(t,l);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"lottery"},"Lottery"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Anyone can easily create their own Lottery application and run it on the Gear Network. To do this, Gear created an example of the Lottery smart contract, which is available on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/lottery"},"GitHub"),". "),(0,o.kt)("p",null,"This article explains the programming interface, data structure, basic functions and explains their purpose. It can be used as is or modified to suit your own scenarios."),(0,o.kt)("p",null,"In this example, whoever initializes the contract is considered the lottery owner. Only the owner has the right to start/finish the lottery. Players are added to the lottery themselves by sending a message with their bet to the contract. Then players monitor the state of the lottery. The winner is determined randomly."),(0,o.kt)("h2",{id:"source-files"},"Source files"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"lottery/src/lib.rs")," - contains functions of the lottery contract."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"lottery/io/src/lib.rs")," - contains Enums and structs that the contract receives and sends in the reply.")),(0,o.kt)("h2",{id:"structs"},"Structs"),(0,o.kt)("p",null,"The contract has the following structs:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"struct Lottery {\n\xa0 \xa0 lottery_state: LotteryState,\n\xa0 \xa0 lottery_owner: ActorId,\n\xa0 \xa0 token_address: Option<ActorId>,\n\xa0 \xa0 players: BTreeMap<u32, Player>,\n\xa0 \xa0 lottery_history: BTreeMap<u32, ActorId>,\n\xa0 \xa0 lottery_id: u32,\n\xa0 \xa0 lottery_balance: u128,\n}\n")),(0,o.kt)("p",null,"where:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lottery_state")," - Lottery state: Start Time, End time of the lottery"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lottery_owner")," - The address of the lottery owner who initialized the contract"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"token_address")," - address of the token contract"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"players")," - 'map' of the lottery players"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lottery_history")," - 'map'  of the lottery winners"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lottery_id")," \u2013 current lottery id"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"lottery_balance")," - the total amount of bets in the lottery"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LotteryState")," struct:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct LotteryState {\n\xa0 \xa0 pub lottery_started: bool,\n\xa0 \xa0 pub lottery_start_time: u64,\n\xa0 \xa0 pub lottery_duration: u64,\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Player")," struct:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Player {\n\xa0 \xa0 pub player_id: ActorId,\n\xa0 \xa0 pub balance: u128,\n}\n")),(0,o.kt)("h2",{id:"enums"},"Enums"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum LtAction {\n\xa0 \xa0 Enter(u128),\n\xa0 \xa0 StartLottery {\n\xa0 \xa0 \xa0 \xa0 duration: u64,\n\xa0 \xa0 \xa0 \xa0 token_address: Option<ActorId>,\n\xa0 \xa0 },\n\xa0 \xa0 LotteryState,\n\xa0 \xa0 PickWinner,\n}\n\npub enum LtEvent {\n\xa0 \xa0 LotteryState(LotteryState),\n\xa0 \xa0 Winner(u32),\n\xa0 \xa0 PlayerAdded(u32),\n}\n\npub enum LtState {\n\xa0 \xa0 GetWinners,\n\xa0 \xa0 GetPlayers,\n\xa0 \xa0 BalanceOf(u32),\n\xa0 \xa0 LotteryState,\n}\n\npub enum LtStateReply {\n\xa0 \xa0 Winners(BTreeMap<u32, ActorId>),\n\xa0 \xa0 Players(BTreeMap<u32, Player>),\n\xa0 \xa0 Balance(u128),\n\xa0 \xa0 LotteryState(LotteryState),\n}\n")),(0,o.kt)("h2",{id:"functions"},"Functions"),(0,o.kt)("p",null,"Lottery contract interacts with fungible token contract through function ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer_tokens"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn transfer_tokens(\n    &mut self,\n    from: &ActorId, /// - the sender address\n    to: &ActorId, /// - the recipient address\n    amount_tokens: u128 /// - the amount of tokens\n)\n")),(0,o.kt)("p",null,"This function sends a message (the action is defined in the enum\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"FTAction"),") and gets a reply (the reply is defined in the enum\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"FTEvent"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let _transfer_response: FTEvent = msg::send_and_wait_for_reply(\n    self.token_address.unwrap(), /// - the fungible token contract address\n    FTAction::Transfer {        /// - action in the fungible token-contract\n        from: *from,\n        to: *to,\n        amount: amount_tokens,\n    },\n    0,\n)\n")),(0,o.kt)("p",null,"Launches a lottery. Only the owner can launch a lottery. Lottery must not have been launched earlier."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"fn start_lottery(\n    &mut self,\n    duration: u64,\n    token_address: Option<ActorId>\n)\n")),(0,o.kt)("p",null,"Called by a player in order to participate in the lottery. The player cannot enter the lottery more than once."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn enter(\n    &mut self,\n    amount: u128\n)\n")),(0,o.kt)("p",null,"Lottery winner calculation. Only the owner can pick the winner."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"async fn pick_winner(\n    &mut self\n)\n")),(0,o.kt)("p",null,"These functions are called in\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"async fn main()"),"\xa0through enum\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"LtAction"),"."),(0,o.kt)("p",null,"This is the entry point to the program, and the program is waiting for a message in ",(0,o.kt)("inlineCode",{parentName:"p"},"LtAction")," format."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[gstd::async_main]\nasync fn main() {\n\xa0 \xa0 if msg::source() == ZERO_ID {\n\xa0 \xa0 \xa0 \xa0 panic!("Message from zero address");\n\xa0 \xa0 }\n\n\xa0 \xa0 let action: LtAction = msg::load().expect("Could not load Action");\n\xa0 \xa0 let lottery: &mut Lottery = unsafe { LOTTERY.get_or_insert(Lottery::default()) };\n\n\xa0 \xa0 match action {\n\xa0 \xa0 \xa0 \xa0 LtAction::Enter(amount) => {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 lottery.enter(amount).await;\n\xa0 \xa0 \xa0 \xa0 }\n\n\xa0 \xa0 \xa0 \xa0 LtAction::StartLottery {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 duration,\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 token_address,\n\xa0 \xa0 \xa0 \xa0 } => {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 lottery.start_lottery(duration, token_address);\n\xa0 \xa0 \xa0 \xa0 }\n\n\xa0 \xa0 \xa0 \xa0 LtAction::LotteryState => {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 msg::reply(LtEvent::LotteryState(lottery.lottery_state.clone()), 0).unwrap();\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 debug!("LotteryState: {:?}", lottery.lottery_state);\n\xa0 \xa0 \xa0 \xa0 }\n\n\xa0 \xa0 \xa0 \xa0 LtAction::PickWinner => {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 lottery.pick_winner().await;\n\xa0 \xa0 \xa0 \xa0 }\n\xa0 \xa0 }\n}\n')),(0,o.kt)("p",null,"It is also important to have the ability to read the contract state off-chain. It is defined in the\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"fn meta_state()"),". The contract receives a request to read the certain data (the possible requests are defined in struct\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"LtState")," ) and sends replies. The contract replies about its state are defined in the enum\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"LtStateReply"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub unsafe extern "C" fn meta_state() -> *mut [i32; 2] {\n\xa0 \xa0 let query: LtState = msg::load().expect("failed to decode input argument");\n\xa0 \xa0 let lottery: &mut Lottery = LOTTERY.get_or_insert(Lottery::default());\n\n\xa0 \xa0 let encoded = match query {\n\xa0 \xa0 \xa0 \xa0 LtState::GetPlayers => LtStateReply::Players(lottery.players.clone()).encode(),\n\xa0 \xa0 \xa0 \xa0 LtState::GetWinners => LtStateReply::Winners(lottery.lottery_history.clone()).encode(),\n\xa0 \xa0 \xa0 \xa0 LtState::LotteryState => LtStateReply::LotteryState(lottery.lottery_state.clone()).encode(),\n\n\xa0 \xa0 \xa0 \xa0 LtState::BalanceOf(index) => {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 if let Some(player) = lottery.players.get(&index) {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 LtStateReply::Balance(player.balance).encode()\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 } else {\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 LtStateReply::Balance(0).encode()\n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 }\n\xa0 \xa0 \xa0 \xa0 }\n\xa0 \xa0 };\n\n\xa0 \xa0 gstd::util::to_leak_ptr(encoded)\n}\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"A source code of the contract example provided by Gear is available on GitHub: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/lottery/blob/master/src/lib.rs"},(0,o.kt)("inlineCode",{parentName:"a"},"lottery/src/lib.rs")),"."),(0,o.kt)("p",null,"See also an examples of the smart contract testing implementation based on gtest:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/lottery/blob/master/src/simple_tests.rs"},(0,o.kt)("inlineCode",{parentName:"a"},"simple_tests.rs")),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/lottery/blob/master/src/panic_tests.rs"},(0,o.kt)("inlineCode",{parentName:"a"},"panic_tests.rs")),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/gear-dapps/lottery/blob/master/src/token_tests.rs"},(0,o.kt)("inlineCode",{parentName:"a"},"token_tests.rs")),"."))),(0,o.kt)("p",null,"For more details about testing smart contracts written on Gear, refer to this article: ",(0,o.kt)("a",{parentName:"p",href:"/developing-contracts/testing"},"Program Testing"),"."))}m.isMDXComponent=!0}}]);